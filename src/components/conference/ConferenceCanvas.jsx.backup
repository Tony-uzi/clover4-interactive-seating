// Conference canvas component with Konva - Enhanced version

import React, { useRef, useState, useEffect } from 'react';
import { Stage, Layer, Rect, Circle, Text, Group, Line, Image, Transformer } from 'react-konva';
import useImage from 'use-image';
import { CONFERENCE_ELEMENTS, getElementConfig } from '../../lib/canvas/shapes';
import ZoomControls from '../shared/ZoomControls';

const PIXELS_PER_METER = 40; // 40 pixels = 1 meter
const GRID_SIZE = 0.5; // Grid every 0.5 meters

// Image component for Konva
function KonvaImage({ src, ...props }) {
  const [image] = useImage(src);
  return <Image image={image} {...props} />;
}

export default function ConferenceCanvas({
  elements,
  onElementsChange,
  roomWidth = 24,
  roomHeight = 16,
  selectedElementId,
  onSelectElement,
  guests = [],
  readOnly = false,
  onRoomResize,
}) {
  const stageRef = useRef(null);
  const transformerRef = useRef(null);
  const [scale, setScale] = useState(1);
  const [stagePos, setStagePos] = useState({ x: 20, y: 20 });

  const canvasWidth = roomWidth * PIXELS_PER_METER;
  const canvasHeight = roomHeight * PIXELS_PER_METER;

  // Update transformer when selection changes
  useEffect(() => {
    if (!transformerRef.current || readOnly) return;

    const stage = stageRef.current;
    if (!stage) return;

    const selectedNode = stage.findOne(`#element-${selectedElementId}`);

    if (selectedNode) {
      transformerRef.current.nodes([selectedNode]);
      transformerRef.current.getLayer().batchDraw();
    } else {
      transformerRef.current.nodes([]);
    }
  }, [selectedElementId, readOnly]);

  // Handle element drag
  const handleDragEnd = (e, element) => {
    if (readOnly) return;
    const newElements = elements.map(el =>
      el.id === element.id
        ? {
            ...el,
            x: e.target.x() / PIXELS_PER_METER,
            y: e.target.y() / PIXELS_PER_METER,
          }
        : el
    );
    onElementsChange(newElements);
  };

  // Handle element transform (resize/rotate)
  const handleTransformEnd = (e, element) => {
    if (readOnly) return;

    const node = e.target;
    const scaleX = node.scaleX();
    const scaleY = node.scaleY();

    // Reset scale and apply to width/height
    node.scaleX(1);
    node.scaleY(1);

    const newElements = elements.map(el =>
      el.id === element.id
        ? {
            ...el,
            x: node.x() / PIXELS_PER_METER,
            y: node.y() / PIXELS_PER_METER,
            width: Math.max(0.1, (node.width() * scaleX) / PIXELS_PER_METER),
            height: Math.max(0.1, (node.height() * scaleY) / PIXELS_PER_METER),
            rotation: node.rotation(),
          }
        : el
    );
    onElementsChange(newElements);
  };

  // Handle zoom
  const handleWheel = (e) => {
    e.evt.preventDefault();

    const scaleBy = 1.05;
    const stage = stageRef.current;
    const oldScale = stage.scaleX();
    const pointer = stage.getPointerPosition();

    const mousePointTo = {
      x: (pointer.x - stage.x()) / oldScale,
      y: (pointer.y - stage.y()) / oldScale,
    };

    const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
    const limitedScale = Math.max(0.3, Math.min(3, newScale));

    setScale(limitedScale);
    setStagePos({
      x: pointer.x - mousePointTo.x * limitedScale,
      y: pointer.y - mousePointTo.y * limitedScale,
    });
  };

  // Zoom controls
  const handleZoomIn = () => {
    const newScale = Math.min(3, scale * 1.2);
    setScale(newScale);
  };

  const handleZoomOut = () => {
    const newScale = Math.max(0.3, scale / 1.2);
    setScale(newScale);
  };

  const handleZoomReset = () => {
    setScale(1);
    setStagePos({ x: 20, y: 20 });
  };

  // Render grid
  const renderGrid = () => {
    const lines = [];
    const gridStep = GRID_SIZE * PIXELS_PER_METER;

    for (let i = 0; i <= roomWidth / GRID_SIZE; i++) {
      lines.push(
        <Line
          key={`v-${i}`}
          points={[i * gridStep, 0, i * gridStep, canvasHeight]}
          stroke="#e0e0e0"
          strokeWidth={1}
        />
      );
    }

    for (let i = 0; i <= roomHeight / GRID_SIZE; i++) {
      lines.push(
        <Line
          key={`h-${i}`}
          points={[0, i * gridStep, canvasWidth, i * gridStep]}
          stroke="#e0e0e0"
          strokeWidth={1}
        />
      );
    }

    return lines;
  };

  // Render element
  const renderElement = (element) => {
    const config = getElementConfig(element.type);
    if (!config) return null;

    const x = element.x * PIXELS_PER_METER;
    const y = element.y * PIXELS_PER_METER;
    const width = element.width * PIXELS_PER_METER;
    const height = element.height * PIXELS_PER_METER;
    const isSelected = selectedElementId === element.id;

    const assignedGuests = guests.filter(
      g => g.tableNumber === element.label || g.elementId === element.id
    );

    return (
      <Group
        key={element.id}
        id={`element-${element.id}`}
        x={x}
        y={y}
        width={width}
        height={height}
        draggable={!readOnly}
        onDragEnd={(e) => handleDragEnd(e, element)}
        onTransformEnd={(e) => handleTransformEnd(e, element)}
        onClick={() => !readOnly && onSelectElement(element.id)}
        onTap={() => !readOnly && onSelectElement(element.id)}
      >
        {/* Render image if element has one */}
        {config.image ? (
          <KonvaImage
            src={config.image}
            width={width}
            height={height}
          />
        ) : (
          <>
            {/* Main shape */}
            {element.type === 'table_round' ? (
              <Circle
                radius={width / 2}
                x={width / 2}
                y={height / 2}
                fill={config.color}
                stroke={isSelected ? '#2196F3' : config.stroke}
                strokeWidth={isSelected ? 3 : 2}
              />
            ) : (
              <Rect
                width={width}
                height={height}
                fill={config.color}
                stroke={isSelected ? '#2196F3' : config.stroke}
                strokeWidth={isSelected ? 3 : 2}
                cornerRadius={4}
              />
            )}
          </>
        )}

        {/* Label */}
        {element.label && (
          <Text
            text={element.label}
            x={0}
            y={element.type === 'table_round' ? height / 2 - 10 : height / 2 - 10}
            width={width}
            align="center"
            fontSize={14}
            fontStyle="bold"
            fill="#333"
          />
        )}

        {/* Seat indicators for tables */}
        {element.seats > 0 && renderSeats(element, width, height)}

        {/* Guest count badge */}
        {assignedGuests.length > 0 && (
          <Group>
            <Circle
              x={width - 15}
              y={15}
              radius={12}
              fill="#4CAF50"
              stroke="#fff"
              strokeWidth={2}
            />
            <Text
              text={assignedGuests.length.toString()}
              x={width - 15 - 6}
              y={15 - 6}
              fontSize={10}
              fill="#fff"
              fontStyle="bold"
            />
          </Group>
        )}
      </Group>
    );
  };

  // Render seats around table
  const renderSeats = (element, width, height) => {
    const seats = [];
    const seatRadius = 8;

    if (element.type === 'table_round') {
      const radius = width / 2 - seatRadius - 5;
      for (let i = 0; i < element.seats; i++) {
        const angle = (i / element.seats) * 2 * Math.PI - Math.PI / 2;
        const x = width / 2 + radius * Math.cos(angle);
        const y = height / 2 + radius * Math.sin(angle);

        seats.push(
          <Circle
            key={`seat-${i}`}
            x={x}
            y={y}
            radius={seatRadius}
            fill="#fff"
            stroke="#666"
            strokeWidth={1}
          />
        );
      }
    } else {
      const seatsPerSide = Math.ceil(element.seats / 2);
      const spacing = width / (seatsPerSide + 1);

      for (let i = 0; i < Math.floor(element.seats / 2); i++) {
        seats.push(
          <Circle
            key={`seat-top-${i}`}
            x={spacing * (i + 1)}
            y={-seatRadius - 5}
            radius={seatRadius}
            fill="#fff"
            stroke="#666"
            strokeWidth={1}
          />
        );
      }

      for (let i = 0; i < Math.ceil(element.seats / 2); i++) {
        seats.push(
          <Circle
            key={`seat-bottom-${i}`}
            x={spacing * (i + 1)}
            y={height + seatRadius + 5}
            radius={seatRadius}
            fill="#fff"
            stroke="#666"
            strokeWidth={1}
          />
        );
      }
    }

    return seats;
  };

  return (
    <div className="relative w-full h-full bg-gray-50 rounded-lg overflow-hidden">
      <Stage
        ref={stageRef}
        width={window.innerWidth - 500}
        height={window.innerHeight - 200}
        scaleX={scale}
        scaleY={scale}
        x={stagePos.x}
        y={stagePos.y}
        onWheel={handleWheel}
        draggable={true}
        onClick={(e) => {
          // Deselect when clicking on empty space
          if (e.target === e.target.getStage()) {
            onSelectElement(null);
          }
        }}
      >
        <Layer>
          {/* Room boundary */}
          <Rect
            x={0}
            y={0}
            width={canvasWidth}
            height={canvasHeight}
            fill="#ffffff"
            stroke="#333"
            strokeWidth={2}
          />

          {/* Grid */}
          {renderGrid()}

          {/* Room resize handles (corners) */}
          {!readOnly && [
            { x: 0, y: 0, cursor: 'nw-resize' },
            { x: canvasWidth, y: 0, cursor: 'ne-resize' },
            { x: canvasWidth, y: canvasHeight, cursor: 'se-resize' },
            { x: 0, y: canvasHeight, cursor: 'sw-resize' },
          ].map((corner, i) => (
            <Circle
              key={`corner-${i}`}
              x={corner.x}
              y={corner.y}
              radius={8}
              fill="#2196F3"
              stroke="#fff"
              strokeWidth={2}
              draggable={true}
              onMouseEnter={(e) => {
                const container = e.target.getStage().container();
                container.style.cursor = corner.cursor;
              }}
              onMouseLeave={(e) => {
                const container = e.target.getStage().container();
                container.style.cursor = 'default';
              }}
              onDragMove={(e) => {
                // Calculate new room dimensions
                const newWidth = Math.max(10, e.target.x() / PIXELS_PER_METER);
                const newHeight = Math.max(10, e.target.y() / PIXELS_PER_METER);

                if (i === 2 && onRoomResize) {
                  // Bottom-right corner - most common resize
                  onRoomResize(newWidth, newHeight);
                }
              }}
            />
          ))}

          {/* Elements */}
          {elements.map(renderElement)}

          {/* Transformer for selected element */}
          {!readOnly && <Transformer ref={transformerRef} />}
        </Layer>
      </Stage>

      {/* Scale indicator */}
      <div className="absolute top-4 left-4 bg-white px-3 py-2 rounded shadow text-sm">
        缩放: {Math.round(scale * 100)}%
      </div>

      {/* Room dimensions */}
      <div className="absolute top-4 right-4 bg-white px-3 py-2 rounded shadow text-sm">
        房间尺寸: {roomWidth.toFixed(1)}m × {roomHeight.toFixed(1)}m
      </div>

      {/* Zoom controls */}
      {!readOnly && (
        <ZoomControls
          scale={scale}
          onZoomIn={handleZoomIn}
          onZoomOut={handleZoomOut}
          onReset={handleZoomReset}
        />
      )}
    </div>
  );
}
